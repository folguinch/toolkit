window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "toolkit", "modulename": "toolkit", "type": "module", "doc": "<p></p>\n"}, {"fullname": "toolkit.argparse_tools", "modulename": "toolkit.argparse_tools", "type": "module", "doc": "<p>Set of tools for parsing command line arguments.</p>\n"}, {"fullname": "toolkit.argparse_tools.actions", "modulename": "toolkit.argparse_tools.actions", "type": "module", "doc": "<p>Collection of actions to process diferent command line inputs.</p>\n"}, {"fullname": "toolkit.argparse_tools.actions.validate_path", "modulename": "toolkit.argparse_tools.actions", "qualname": "validate_path", "type": "function", "doc": "<p>Performs several checks on input path.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path:</strong>  path to check.</li>\n<li><strong>check_is_file:</strong>  optional; check whether is file and exists.</li>\n<li><strong>check_is_dir:</strong>  optional; check whther is a directory and exists.</li>\n<li><strong>mkdir:</strong>  optional; make directories if they do not exist.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A validated resolved pathlib.Path object</p>\n</blockquote>\n", "signature": "(\n    path: pathlib.Path,\n    check_is_file: bool = False,\n    check_is_dir: bool = False,\n    mkdir: bool = False\n)", "funcdef": "def"}, {"fullname": "toolkit.argparse_tools.actions.validate_paths", "modulename": "toolkit.argparse_tools.actions", "qualname": "validate_paths", "type": "function", "doc": "<p>Performs several checks on input list of file names.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>filenames:</strong>  list of filenames to check.</li>\n<li><strong>check_is_file:</strong>  optional; check whether is file and exists.</li>\n<li><strong>check_is_dir:</strong>  optional; check whther is a directory and exists.</li>\n<li><strong>mkdir:</strong>  optional; make directories if they do not exist.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Validate path.Path from the input strings.</p>\n</blockquote>\n", "signature": "(\n    filenames: Union[str, List[str]],\n    check_is_file: bool = False,\n    check_is_dir: bool = False,\n    mkdir: bool = False\n)", "funcdef": "def"}, {"fullname": "toolkit.argparse_tools.actions.split_values", "modulename": "toolkit.argparse_tools.actions", "qualname": "split_values", "type": "function", "doc": "<p>Split the input values when quotations are used in <code>bash</code>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>values:</strong>  list of values.</li>\n</ul>\n", "signature": "(values: list)", "funcdef": "def"}, {"fullname": "toolkit.argparse_tools.actions.LoadConfig", "modulename": "toolkit.argparse_tools.actions", "qualname": "LoadConfig", "type": "class", "doc": "<p>Action class for loading a configuration file in argparse.</p>\n", "bases": "argparse.Action"}, {"fullname": "toolkit.argparse_tools.actions.LoadArray", "modulename": "toolkit.argparse_tools.actions", "qualname": "LoadArray", "type": "class", "doc": "<p>Action class for loading a np.array from command line.</p>\n", "bases": "argparse.Action"}, {"fullname": "toolkit.argparse_tools.actions.ArrayFromRange", "modulename": "toolkit.argparse_tools.actions", "qualname": "ArrayFromRange", "type": "class", "doc": "<p>Action class for creating a np.array with linspace from command line</p>\n", "bases": "argparse.Action"}, {"fullname": "toolkit.argparse_tools.actions.ArrayFromRange.__init__", "modulename": "toolkit.argparse_tools.actions", "qualname": "ArrayFromRange.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, option_strings, dest, nargs=2, **kwargs)", "funcdef": "def"}, {"fullname": "toolkit.argparse_tools.actions.LoadStructArray", "modulename": "toolkit.argparse_tools.actions", "qualname": "LoadStructArray", "type": "class", "doc": "<p>Load an structured np.array from file.</p>\n", "bases": "argparse.Action"}, {"fullname": "toolkit.argparse_tools.actions.LoadMixedStructArray", "modulename": "toolkit.argparse_tools.actions", "qualname": "LoadMixedStructArray", "type": "class", "doc": "<p>Load a mixed structured np.array from file.</p>\n", "bases": "argparse.Action"}, {"fullname": "toolkit.argparse_tools.actions.LoadTXTArray", "modulename": "toolkit.argparse_tools.actions", "qualname": "LoadTXTArray", "type": "class", "doc": "<p>Load an np.array from file.</p>\n", "bases": "argparse.Action"}, {"fullname": "toolkit.argparse_tools.actions.LoadFITS", "modulename": "toolkit.argparse_tools.actions", "qualname": "LoadFITS", "type": "class", "doc": "<p>Action for loading a FITS file with astropy</p>\n", "bases": "argparse.Action"}, {"fullname": "toolkit.argparse_tools.actions.LoadCube", "modulename": "toolkit.argparse_tools.actions", "qualname": "LoadCube", "type": "class", "doc": "<p>Action for loading an SpectralCube</p>\n", "bases": "argparse.Action"}, {"fullname": "toolkit.argparse_tools.actions.ListFromFile", "modulename": "toolkit.argparse_tools.actions", "qualname": "ListFromFile", "type": "class", "doc": "<p>Load a list of strings from file.</p>\n", "bases": "argparse.Action"}, {"fullname": "toolkit.argparse_tools.actions.ListFromFile.__init__", "modulename": "toolkit.argparse_tools.actions", "qualname": "ListFromFile.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, option_strings, dest, nargs=None, **kwargs)", "funcdef": "def"}, {"fullname": "toolkit.argparse_tools.actions.ListFromRegex", "modulename": "toolkit.argparse_tools.actions", "qualname": "ListFromRegex", "type": "class", "doc": "<p>Load a list of files from a regular expression.</p>\n", "bases": "argparse.Action"}, {"fullname": "toolkit.argparse_tools.actions.ListFromRegex.__init__", "modulename": "toolkit.argparse_tools.actions", "qualname": "ListFromRegex.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, option_strings, dest, nargs=None, **kwargs)", "funcdef": "def"}, {"fullname": "toolkit.argparse_tools.actions.ReadQuantity", "modulename": "toolkit.argparse_tools.actions", "qualname": "ReadQuantity", "type": "class", "doc": "<p>Read quantity or a quantity list from the cmd line.</p>\n", "bases": "argparse.Action"}, {"fullname": "toolkit.argparse_tools.actions.ReadQuantity.__init__", "modulename": "toolkit.argparse_tools.actions", "qualname": "ReadQuantity.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, option_strings, dest, nargs=2, enforce_list=False, **kwargs)", "funcdef": "def"}, {"fullname": "toolkit.argparse_tools.actions.ReadUnit", "modulename": "toolkit.argparse_tools.actions", "qualname": "ReadUnit", "type": "class", "doc": "<p>Read quantity or a quantity list from the cmd line.</p>\n", "bases": "argparse.Action"}, {"fullname": "toolkit.argparse_tools.actions.PeakPosition", "modulename": "toolkit.argparse_tools.actions", "qualname": "PeakPosition", "type": "class", "doc": "<p>Load FITS file and get peak position as <code>SkyCoord</code>.</p>\n", "bases": "argparse.Action"}, {"fullname": "toolkit.argparse_tools.actions.PeakPosition.__init__", "modulename": "toolkit.argparse_tools.actions", "qualname": "PeakPosition.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, option_strings, dest, nargs='*', **kwargs)", "funcdef": "def"}, {"fullname": "toolkit.argparse_tools.actions.ReadSkyCoords", "modulename": "toolkit.argparse_tools.actions", "qualname": "ReadSkyCoords", "type": "class", "doc": "<p>Read one or more sky coordinates.</p>\n", "bases": "argparse.Action"}, {"fullname": "toolkit.argparse_tools.actions.ReadSkyCoords.__init__", "modulename": "toolkit.argparse_tools.actions", "qualname": "ReadSkyCoords.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, option_strings, dest, nargs=2, **kwargs)", "funcdef": "def"}, {"fullname": "toolkit.argparse_tools.actions.NormalizePath", "modulename": "toolkit.argparse_tools.actions", "qualname": "NormalizePath", "type": "class", "doc": "<p>Normalizes a path or filename.</p>\n", "bases": "argparse.Action"}, {"fullname": "toolkit.argparse_tools.actions.MakePath", "modulename": "toolkit.argparse_tools.actions", "qualname": "MakePath", "type": "class", "doc": "<p>Check and create directory if needed.</p>\n", "bases": "argparse.Action"}, {"fullname": "toolkit.argparse_tools.actions.CheckFile", "modulename": "toolkit.argparse_tools.actions", "qualname": "CheckFile", "type": "class", "doc": "<p>Validates files and check if they exist.</p>\n", "bases": "argparse.Action"}, {"fullname": "toolkit.argparse_tools.actions.StartLogger", "modulename": "toolkit.argparse_tools.actions", "qualname": "StartLogger", "type": "class", "doc": "<p>Create a logger.</p>\n\n<p>If nargs=? (default), log to default or const if provided and flag used\nelse log only to stdout.\nFor verbose levels, the standard option_string values are:\n  -v, --vv, --vvv, --log, --info, --debug, --fulldebug\nWith: -v = --log = --info\n      --vv = --debug\n      --vvv = --fulldebug\nOther values will create a normal logger.</p>\n", "bases": "argparse.Action"}, {"fullname": "toolkit.argparse_tools.actions.StartLogger.__init__", "modulename": "toolkit.argparse_tools.actions", "qualname": "StartLogger.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    option_strings,\n    dest,\n    nargs='?',\n    metavar='LOGFILE',\n    const=None,\n    default=None,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "toolkit.argparse_tools.functions", "modulename": "toolkit.argparse_tools.functions", "type": "module", "doc": "<p>Functions for helping the processing of arguments.</p>\n"}, {"fullname": "toolkit.argparse_tools.functions.positions_to_pixels", "modulename": "toolkit.argparse_tools.functions", "qualname": "positions_to_pixels", "type": "function", "doc": "<p>Store the positions in the <code>args</code> object as pixels.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>args:</strong>  argument parser.</li>\n<li><strong>wcs:</strong>  optional; WCS to convert coordinates to pixels.</li>\n</ul>\n", "signature": "(\n    args: argparse.ArgumentParser,\n    wcs: Union[astropy.wcs.wcs.WCS, NoneType] = None\n) -> None", "funcdef": "def"}, {"fullname": "toolkit.argparse_tools.functions.pixels_to_positions", "modulename": "toolkit.argparse_tools.functions", "qualname": "pixels_to_positions", "type": "function", "doc": "<p>Store the positions in <code>args</code> as <code>SkyCoords</code>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>args:</strong>  argument parser.</li>\n<li><strong>wcs:</strong>  optional; WCS to convert coordinates to pixels.</li>\n</ul>\n", "signature": "(\n    args: argparse.ArgumentParser,\n    wcs: Union[astropy.wcs.wcs.WCS, NoneType] = None\n) -> None", "funcdef": "def"}, {"fullname": "toolkit.argparse_tools.loaders", "modulename": "toolkit.argparse_tools.loaders", "type": "module", "doc": "<p>Loader functions for <code>argparsers</code>.</p>\n"}, {"fullname": "toolkit.argparse_tools.loaders.load_spectral_cube", "modulename": "toolkit.argparse_tools.loaders", "qualname": "load_spectral_cube", "type": "function", "doc": "<p>Read a spectral_cube object and store it in args.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>args:</strong>  NameSpace to store the cube.</li>\n<li><strong>cubename:</strong>  optional; spectral cube file name.</li>\n<li><strong>use_dask:</strong>  optional; use dask?</li>\n</ul>\n", "signature": "(\n    args,\n    cubename: Union[str, NoneType] = None,\n    use_dask: bool = False\n) -> None", "funcdef": "def"}, {"fullname": "toolkit.argparse_tools.loaders.load_config", "modulename": "toolkit.argparse_tools.loaders", "qualname": "load_config", "type": "function", "doc": "<p>Read a configuration file and store it in args.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>args:</strong>  NameSpace to store the configparser.</li>\n<li><strong>config:</strong>  optional; configuration file name.</li>\n</ul>\n", "signature": "(args, config: Union[str, NoneType] = None)", "funcdef": "def"}, {"fullname": "toolkit.argparse_tools.parents", "modulename": "toolkit.argparse_tools.parents", "type": "module", "doc": "<p>Argparse parent parsers commonly used.</p>\n"}, {"fullname": "toolkit.argparse_tools.parents.astro_source", "modulename": "toolkit.argparse_tools.parents", "qualname": "astro_source", "type": "function", "doc": "<p>Read an <code>astro_source.Source</code> and return it in parser.</p>\n", "signature": "() -> argparse.ArgumentParser", "funcdef": "def"}, {"fullname": "toolkit.argparse_tools.parents.source_position", "modulename": "toolkit.argparse_tools.parents", "qualname": "source_position", "type": "function", "doc": "<p>Parent for reading a source position.</p>\n\n<p>The function creates 2 defaults:</p>\n\n<ul>\n<li><code>pos</code>: a list of position pairs. The values stored ar in xy pixels.</li>\n<li><code>position_fn</code>: which generates and fills the <code>pos</code> from the command\nline input.</li>\n</ul>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>required:</strong>  optional; is the argument required?</li>\n<li><strong>function:</strong>  optional; a function mapping the postion values to xy pixels.</li>\n</ul>\n", "signature": "(\n    required: bool = False,\n    function: Callable[[argparse.Namespace], NoneType] = <function positions_to_pixels>\n) -> argparse.ArgumentParser", "funcdef": "def"}, {"fullname": "toolkit.argparse_tools.parents.logger", "modulename": "toolkit.argparse_tools.parents", "qualname": "logger", "type": "function", "doc": "<p>Parent parser to initiate a logging system.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>filename:</strong>  optional; default filename for logging.</li>\n</ul>\n", "signature": "(\n    filename: Union[pathlib.Path, str, NoneType] = None\n) -> argparse.ArgumentParser", "funcdef": "def"}, {"fullname": "toolkit.argparse_tools.parents.verify_files", "modulename": "toolkit.argparse_tools.parents", "qualname": "verify_files", "type": "function", "doc": "<p>Create a parser with the input strings that verify for file\nexistance.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>args:</strong>  argument name.</li>\n<li><strong>kwargs:</strong>  additional arguments for <code>add_argument</code> for each <code>arg</code>.</li>\n</ul>\n", "signature": "(*args, **kwargs) -> argparse.ArgumentParser", "funcdef": "def"}, {"fullname": "toolkit.argparse_tools.parents.paths", "modulename": "toolkit.argparse_tools.parents", "qualname": "paths", "type": "function", "doc": "<p>Create a parser with the input strings that create paths.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>args:</strong>  argument name.</li>\n<li><strong>kwargs:</strong>  additional arguments for <code>add_argument</code> for each <code>arg</code>.</li>\n</ul>\n", "signature": "(*args, **kwargs) -> argparse.ArgumentParser", "funcdef": "def"}, {"fullname": "toolkit.array_utils", "modulename": "toolkit.array_utils", "type": "module", "doc": "<p>Functions for working with numpy arrays.</p>\n"}, {"fullname": "toolkit.array_utils.check_composed_units", "modulename": "toolkit.array_utils", "qualname": "check_composed_units", "type": "function", "doc": "<p>Check composed units from strings in file headers.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>line:</strong>  text line splitted.</li>\n<li><strong>left_delimiter:</strong>  optional; left char delimiter for composed unit.</li>\n<li><strong>right_delimiter:</strong>  optional; right char delimiter for composed unit.</li>\n</ul>\n\n<h6 id=\"return\">Return</h6>\n\n<blockquote>\n  <p>Validated units.</p>\n</blockquote>\n", "signature": "(\n    line: List[str],\n    left_delimiter: str = '[',\n    right_delimiter: str = ']'\n) -> List[str]", "funcdef": "def"}, {"fullname": "toolkit.array_utils.filename_to_list", "modulename": "toolkit.array_utils", "qualname": "filename_to_list", "type": "function", "doc": "<p>Determine if there are multiple file names.</p>\n", "signature": "(file_name: Union[pathlib.Path, List[pathlib.Path]]) -> Union[list, bool]", "funcdef": "def"}, {"fullname": "toolkit.array_utils.load_struct_array", "modulename": "toolkit.array_utils", "qualname": "load_struct_array", "type": "function", "doc": "<p>Load a structured array table.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>file_name:</strong>  file or files to be loaded.</li>\n<li><strong>usecols:</strong>  optional; columns to load.</li>\n<li><strong>nounit:</strong>  optional; char for columns without units.</li>\n<li><strong>empty_unit:</strong>  optional; unit for nounit column.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>data: structured array.\n  units: dictionary with the units.</p>\n</blockquote>\n", "signature": "(\n    file_name: Union[pathlib.Path, List[pathlib.Path]],\n    usecols: Union[List[int], NoneType] = None,\n    nounit: str = '-',\n    empty_unit: Union[astropy.units.core.Unit, NoneType] = Unit(dimensionless)\n) -> Union[Tuple[<built-in function array>, dict], List[Tuple[<built-in function array>, dict]]]", "funcdef": "def"}, {"fullname": "toolkit.array_utils.load_mixed_struct_array", "modulename": "toolkit.array_utils", "qualname": "load_mixed_struct_array", "type": "function", "doc": "<p>Load a structured array table of mixed types.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>file_name:</strong>  file or files to be loaded.</li>\n<li><strong>usecols:</strong>  optional; columns to load.</li>\n<li><strong>nounit:</strong>  optional; char for columns without units.</li>\n<li><strong>empty_unit:</strong>  optional; unit for nounit column.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>data: structured array.\n  units: dictionary with the units.</p>\n</blockquote>\n", "signature": "(\n    file_name: Union[pathlib.Path, List[pathlib.Path]],\n    usecols: Union[List[int], NoneType] = None,\n    nounit: str = '-',\n    empty_unit: Union[astropy.units.core.Unit, NoneType] = None\n) -> Union[Tuple[<built-in function array>, dict], List[Tuple[<built-in function array>, dict]]]", "funcdef": "def"}, {"fullname": "toolkit.array_utils.save_struct_array", "modulename": "toolkit.array_utils", "qualname": "save_struct_array", "type": "function", "doc": "<p>Save a structured array table.</p>\n\n<p>Save the data in a way it can be loaded by the load_struct_array function.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>file_name:</strong>  name of the file.</li>\n<li><strong>data:</strong>  array to save.</li>\n<li><strong>units:</strong>  physical units of the data.</li>\n<li><strong>fmt:</strong>  optional; string format for the data.</li>\n</ul>\n", "signature": "(\n    file_name: pathlib.Path,\n    data: <built-in function array>,\n    units: dict,\n    fmt: str = '%10.4e\\t'\n) -> None", "funcdef": "def"}, {"fullname": "toolkit.astro_tools", "modulename": "toolkit.astro_tools", "type": "module", "doc": "<p>Collection of tools for working with astronomical packages.</p>\n"}, {"fullname": "toolkit.astro_tools.cube_utils", "modulename": "toolkit.astro_tools.cube_utils", "type": "module", "doc": "<p>Tools for working with <code>SpectralCube</code> objects.</p>\n"}, {"fullname": "toolkit.astro_tools.cube_utils.get_restfreq", "modulename": "toolkit.astro_tools.cube_utils", "qualname": "get_restfreq", "type": "function", "doc": "<p>Get rest frequency from cube header.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cube:</strong>  <code>SpectralCube</code> object.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The rest frequency from cube header as a <code>Quantity</code> object.</p>\n</blockquote>\n", "signature": "(\n    cube: spectral_cube.spectral_cube.SpectralCube\n) -> astropy.units.quantity.Quantity", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.cube_utils.get_cube_rms", "modulename": "toolkit.astro_tools.cube_utils", "qualname": "get_cube_rms", "type": "function", "doc": "<p>Do a quick calculation of the rms.</p>\n\n<p>The <code>sampled</code> calculation is recommended for big data cubes.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cube:</strong>  spectral cube.</li>\n<li><strong>use_header:</strong>  use value stored in header (if any).</li>\n<li><strong>sampled:</strong>  optional; determine the rms from a sample of channels.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n", "signature": "(\n    cube: spectral_cube.spectral_cube.SpectralCube,\n    use_header: bool = False,\n    sampled: bool = False,\n    log: Callable = <built-in function print>\n) -> astropy.units.quantity.Quantity", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.cube_utils.vel_axis", "modulename": "toolkit.astro_tools.cube_utils", "qualname": "vel_axis", "type": "function", "doc": "<p>Get the spectral axis in velocity units.</p>\n\n<p>If the cube spectral axis units are equivalent to vel_units but restfreq is\nnot None, it recalculates the velocity at the given restfreq.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cube:</strong>  spectral cube to extract the spectral axis.</li>\n<li><strong>restfreq:</strong>  optional; restfrequency of the spectral axis.</li>\n<li><strong>vel_units:</strong>  optional; the velocity units.</li>\n</ul>\n", "signature": "(\n    cube: spectral_cube.spectral_cube.SpectralCube,\n    restfreq: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    vel_units: astropy.units.core.Unit = Unit(\"km / s\")\n) -> astropy.units.quantity.Quantity", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.cube_utils.freq_axis", "modulename": "toolkit.astro_tools.cube_utils", "qualname": "freq_axis", "type": "function", "doc": "<p>Get the spectral axis in frequency units.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cube:</strong>  spectral cube to extract the spectral axis.</li>\n<li><strong>freq_units:</strong>  optional; frequency axis units.</li>\n</ul>\n", "signature": "(\n    cube: spectral_cube.spectral_cube.SpectralCube,\n    freq_units: astropy.units.core.Unit = Unit(\"GHz\")\n) -> astropy.units.quantity.Quantity", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.cube_utils.moments01", "modulename": "toolkit.astro_tools.cube_utils", "qualname": "moments01", "type": "function", "doc": "<p>Calculate zeroth and first moment maps from cube.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cube:</strong>  spectral cube.</li>\n<li><strong>low:</strong>  optional; lower flux limit.</li>\n<li><strong>up:</strong>  optional; upper flux limit.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A moment 0 and a moment 1 maps</p>\n</blockquote>\n", "signature": "(\n    cube: spectral_cube.spectral_cube.SpectralCube,\n    low: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    up: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    filenames: Sequence[Union[str, pathlib.Path]] = ()\n) -> List[~Projection]", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.cube_utils.get_spectral_limits", "modulename": "toolkit.astro_tools.cube_utils", "qualname": "get_spectral_limits", "type": "function", "doc": "<p>Convert input ranges to ranges that can be applied to a spectral cube.</p>\n\n<p>For frequency and velocity ranges, it converts the values to the spectral\nunits of the cube. Channel range is sorted and returned. Channel half width\nrequires a line frequency and a vlsr to determine the range from the\nspectral axis around a specific line.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cube:</strong>  spectral cube.</li>\n<li><strong>freq_range:</strong>  frequency range.</li>\n<li><strong>vel_range:</strong>  velocity range.</li>\n<li><strong>chan_range:</strong>  channel range.</li>\n<li><strong>chan_halfwidth:</strong>  number of channel in half the spectral range.</li>\n<li><strong>vlsr:</strong>  required by chan_halfwidth; vlsr velocity.</li>\n<li><strong>linefreq:</strong>  required by chan_halfwidth; line frequency.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n", "signature": "(\n    cube: spectral_cube.spectral_cube.SpectralCube,\n    freq_range: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    vel_range: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    chan_range: Union[List[int], NoneType] = None,\n    chan_halfwidth: Union[int, NoneType] = None,\n    vlsr: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    linefreq: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    log: Callable = <built-in function print>\n) -> Union[astropy.units.quantity.Quantity, list]", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.cube_utils.get_subcube", "modulename": "toolkit.astro_tools.cube_utils", "qualname": "get_subcube", "type": "function", "doc": "<p>Extract a sub-spectral cube in any of the axes.</p>\n\n<p>The spectral cube can be saved by providing a filenamebase. The output\nfilename will replace the suffix (extension) of filenamebase with\n'.subcube.fits'.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cube:</strong>  spectral cube.</li>\n<li><strong>freq_range:</strong>  frequency range.</li>\n<li><strong>vel_range:</strong>  velocity range.</li>\n<li><strong>chan_range:</strong>  channel range.</li>\n<li><strong>chan_halfwidth:</strong>  number of channel in half the spectral range.</li>\n<li><strong>vlsr:</strong>  required by chan_halfwidth; vlsr velocity.</li>\n<li><strong>linefreq:</strong>  required by chan_halfwidth; line frequency.</li>\n<li><strong>blc_trc:</strong>  optional; positions of the bottom left and top right corners.</li>\n<li><strong>xy_ranges:</strong>  optional; ranges in x and y axes.</li>\n<li><strong>put_rms:</strong>  put the rms in the header.</li>\n<li><strong>filenamebase:</strong>  optional; base of the output filename.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n", "signature": "(\n    cube: spectral_cube.spectral_cube.SpectralCube,\n    freq_range: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    vel_range: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    chan_range: Union[List[int], NoneType] = None,\n    chan_halfwidth: Union[int, NoneType] = None,\n    vlsr: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    linefreq: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    blc_trc: Union[List[int], NoneType] = None,\n    xy_ranges: Union[List[int], NoneType] = None,\n    put_rms: bool = False,\n    filenamebase: Union[pathlib.Path, str, NoneType] = None,\n    log: Callable = <built-in function print>\n) -> spectral_cube.spectral_cube.SpectralCube", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.cube_utils.moment_from_config", "modulename": "toolkit.astro_tools.cube_utils", "qualname": "moment_from_config", "type": "function", "doc": "<p>Calculate the moments with parameters from config file.</p>\n\n<p>The parameters are passed to the <code>get_moment</code> function.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cube:</strong>  spectral cube.</li>\n<li><strong>mom:</strong>  moment to calculate.</li>\n<li><strong>config:</strong>  advanced configuration proxy.</li>\n<li><strong>vlsr:</strong>  optional; vlsr velocity.</li>\n<li><strong>filenamebase:</strong>  optional; base of the output file name.</li>\n<li><strong>filename:</strong>  optional; output moment file name.</li>\n</ul>\n", "signature": "(\n    cube: spectral_cube.spectral_cube.SpectralCube,\n    mom: int,\n    config: ~ConfigParserAdv,\n    vlsr: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    filenamebase: Union[~Path, NoneType] = None,\n    filename: Union[~Path, NoneType] = None\n) -> ~Projection", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.cube_utils.get_moment", "modulename": "toolkit.astro_tools.cube_utils", "qualname": "get_moment", "type": "function", "doc": "<p>Calculate a moment map.</p>\n\n<p>If filenamebase is given, the final file name will be filenamebase with\nsuffix (extension) replaced by '.subcube.fits'.</p>\n\n<p>Note that if the linefreq is not given, the rest frequency value in the\ncube header will be used, so the velocity values will be calculated with\nrespect to that value.</p>\n\n<p>If beams differ more than 1% <code>spectral_cube</code> will raise <code>ValueError</code>. The\nmoment calculation can be skipped in this case by setting <code>skip_beam_error</code>\nto <code>True</code>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cube:</strong>  spectral cube.</li>\n<li><strong>mom:</strong>  moment to calculate.</li>\n<li><strong>linefreq:</strong>  optional; line frequency.</li>\n<li><strong>filenamebase:</strong>  optional; base of the output file name.</li>\n<li><strong>filename:</strong>  optional; output moment file name.</li>\n<li><strong>lower_limit:</strong>  optional; intensity lower limit.</li>\n<li><strong>upper_limit:</strong>  optional; intensity upper limit.</li>\n<li><strong>nsigma:</strong>  determine lower_limit from number of sigma (rms) values.</li>\n<li><strong>rms:</strong>  optional; cube rms.</li>\n<li><strong>auto_rms:</strong>  optional; calculate the cube rms.</li>\n<li><strong>skip_beam_error:</strong>  optional; raise exception if beams differ more than 1%?</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n<li><strong>kwargs:</strong>  additional parameters for get_subcube function.</li>\n</ul>\n", "signature": "(\n    cube: spectral_cube.spectral_cube.SpectralCube,\n    mom: int,\n    linefreq: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    filenamebase: Union[~Path, NoneType] = None,\n    filename: Union[~Path, NoneType] = None,\n    lower_limit: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    upper_limit: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    nsigma: float = 5.0,\n    rms: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    auto_rms: bool = False,\n    skip_beam_error: bool = False,\n    log: Callable = <built-in function print>,\n    **kwargs\n) -> ~Projection", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.cube_utils.spectrum_at_position", "modulename": "toolkit.astro_tools.cube_utils", "qualname": "spectrum_at_position", "type": "function", "doc": "<p>Extract spectrum at position.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cube:</strong>  spectral cube.</li>\n<li><strong>position:</strong>  coordiante or pixel where to extract the spectrum from.</li>\n<li><strong>spectral_axis_unit:</strong>  optional; unit of the spectral axis.</li>\n<li><strong>restfreq:</strong>  optional; rest frequency.</li>\n<li><strong>vlsr:</strong>  optional; LSR velocity.</li>\n<li><strong>radius:</strong>  optional; average pixels around this radius.</li>\n<li><strong>size:</strong>  optional; use ellipse major and minor axes to get radius.</li>\n<li><strong>area_pix:</strong>  optional; source area in pixels.</li>\n<li><strong>filename:</strong>  optional; output filename.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>xaxis: an array with the spectral axis.\n  spec: the spectrum.</p>\n</blockquote>\n", "signature": "(\n    cube: spectral_cube.spectral_cube.SpectralCube,\n    position: ~Position,\n    spectral_axis_unit: Union[astropy.units.core.Unit, NoneType] = None,\n    restfreq: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    vlsr: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    radius: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    size: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    area_pix: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    filename: Union[pathlib.Path, str, NoneType] = None,\n    log: Union[Callable, NoneType] = <built-in function print>\n) -> Tuple[astropy.units.quantity.Quantity]", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.images", "modulename": "toolkit.astro_tools.images", "type": "module", "doc": "<p>Tools for extracting information from 2-D images.</p>\n"}, {"fullname": "toolkit.astro_tools.images.copy_header_keys", "modulename": "toolkit.astro_tools.images", "qualname": "copy_header_keys", "type": "function", "doc": "<p>Copy selected keys from one header into another header.</p>\n", "signature": "(\n    ref_header: Dict,\n    new_header: Dict,\n    keys: Sequence = ('BUNIT', 'BMIN', 'BMAJ', 'BPA')\n) -> Dict", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.images.squeeze_image", "modulename": "toolkit.astro_tools.images", "qualname": "squeeze_image", "type": "function", "doc": "<p>Reduce number of axes not used in input image.</p>\n", "signature": "(\n    image: astropy.io.fits.hdu.image.PrimaryHDU\n) -> astropy.io.fits.hdu.image.PrimaryHDU", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.images.pixels_per_beam", "modulename": "toolkit.astro_tools.images", "qualname": "pixels_per_beam", "type": "function", "doc": "<p>Number of pixels in the beam area.</p>\n", "signature": "(image: astropy.io.fits.hdu.image.PrimaryHDU)", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.images.get_peak", "modulename": "toolkit.astro_tools.images", "qualname": "get_peak", "type": "function", "doc": "<p>Get the coordinate of the peak and peak value.</p>\n", "signature": "(\n    image: astropy.io.fits.hdu.image.PrimaryHDU\n) -> Tuple[astropy.coordinates.sky_coordinate.SkyCoord, astropy.units.quantity.Quantity]", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.images.position_in_image", "modulename": "toolkit.astro_tools.images", "qualname": "position_in_image", "type": "function", "doc": "<p>Is the <code>position</code> in the <code>image</code>?</p>\n", "signature": "(\n    position: astropy.coordinates.sky_coordinate.SkyCoord,\n    image: astropy.io.fits.hdu.image.PrimaryHDU\n) -> bool", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.images.positions_in_image", "modulename": "toolkit.astro_tools.images", "qualname": "positions_in_image", "type": "function", "doc": "<p>Filter positions present in an image.</p>\n", "signature": "(\n    positions: Sequence[astropy.coordinates.sky_coordinate.SkyCoord],\n    image: astropy.io.fits.hdu.image.PrimaryHDU\n) -> List[astropy.coordinates.sky_coordinate.SkyCoord]", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.images.stats_at_position", "modulename": "toolkit.astro_tools.images", "qualname": "stats_at_position", "type": "function", "doc": "<p>Calculate statistics in a circle centered at a given position.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>image:</strong>  the map.</li>\n<li><strong>position:</strong>  center of the circular region.</li>\n<li><strong>radius:</strong>  radius of the circular region.</li>\n<li><strong>stats:</strong>  optional; statistical functions.</li>\n</ul>\n", "signature": "(\n    image: astropy.io.fits.hdu.image.PrimaryHDU,\n    position: astropy.coordinates.sky_coordinate.SkyCoord,\n    radius: astropy.units.quantity.Quantity,\n    stats: Sequence[Callable] = (<function mean at 0x7fe8146d3c20>, <function std at 0x7fe8146d3e60>)\n) -> Sequence[astropy.units.quantity.Quantity]", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.images.stats_in_beam", "modulename": "toolkit.astro_tools.images", "qualname": "stats_in_beam", "type": "function", "doc": "<p>Calculate statistics in a beam sized circle centered at a position.</p>\n\n<p>If <code>beam_radius_factor</code> is given, then the radius of the circle will be\nmultiplied by this number.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>image:</strong>  the map.</li>\n<li><strong>position:</strong>  center of the circular region.</li>\n<li><strong>stats:</strong>  optional; statistical functions.</li>\n<li><strong>beam_radius_factor:</strong>  optional; multiplicative factor for beam raidus.</li>\n</ul>\n", "signature": "(\n    image: astropy.io.fits.hdu.image.PrimaryHDU,\n    position: astropy.coordinates.sky_coordinate.SkyCoord,\n    stats: Sequence[Callable] = (<function mean at 0x7fe8146d3c20>, <function std at 0x7fe8146d3e60>),\n    beam_radius_factor: float = 1\n) -> Sequence[astropy.units.quantity.Quantity]", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.images.image_cutout", "modulename": "toolkit.astro_tools.images", "qualname": "image_cutout", "type": "function", "doc": "<p>Generate a cutout from imput data.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>image:</strong>  data to cut from.</li>\n<li><strong>position:</strong>  central position of the cutout.</li>\n<li><strong>size:</strong>  size of the cutout.</li>\n<li><strong>filename:</strong>  optional; file name to save the cutout.</li>\n</ul>\n", "signature": "(\n    image: astropy.io.fits.hdu.image.PrimaryHDU,\n    position: astropy.coordinates.sky_coordinate.SkyCoord,\n    size: Union[astropy.units.quantity.Quantity, Sequence],\n    filename: Union[pathlib.Path, NoneType] = None\n) -> astropy.io.fits.hdu.image.PrimaryHDU", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.images.identify_structures", "modulename": "toolkit.astro_tools.images", "qualname": "identify_structures", "type": "function", "doc": "<p>Find valid emission structures in input image.</p>\n\n<p>If <code>mask</code> is not given, it first it creates a mask with valid (non-NaN)\ndata. This mask can be combined with a threshold mask if <code>calcmask</code> is set\nto <code>True</code>. This mask is generated from <code>threshold</code> or <code>nsigma*rms</code> with\n<code>rms</code> estimated from the median absolute deviation of the data. Then it\nidentifies connected structures in the mask and filters out structures with\nsmall areas. Finally it looks for the centroid and lenghts along each axes\nfor each structure.</p>\n\n<p>If the input image has beam parameters in the header, then <code>min_area</code> is\nthe minimum number of beam areas for mask structures. Otherwise it is the\nminimum number of pixels for mask structures.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>images:</strong>  input image.</li>\n<li><strong>mask:</strong>  optional; peak mask.</li>\n<li><strong>calcmask:</strong>  optional; calculate a threshold mask?</li>\n<li><strong>threshold:</strong>  optional; emission threshold for mask.</li>\n<li><strong>nsigma:</strong>  optional; number of rms levels for threshold mask.</li>\n<li><strong>min_area:</strong>  optional; number of beam areas or pixels.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A list of coordinates of the centers of structures in the input image.\n  The length along x and y axes of each structure.</p>\n</blockquote>\n", "signature": "(\n    image: astropy.io.fits.hdu.image.PrimaryHDU,\n    mask: Union[<built-in function array>, NoneType] = None,\n    calcmask: bool = False,\n    threshold: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    nsigma: float = 5,\n    min_area: float = 9,\n    plot: Union[pathlib.Path, NoneType] = None,\n    log: Callable = <built-in function print>\n) -> Tuple[List[astropy.coordinates.sky_coordinate.SkyCoord], List[astropy.coordinates.sky_coordinate.SkyCoord], List[astropy.units.quantity.Quantity]]", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.images.intensity_gradient", "modulename": "toolkit.astro_tools.images", "qualname": "intensity_gradient", "type": "function", "doc": "<p>Calculate a gradient map of the input image.</p>\n\n<p>If distance is given the spatial unit of the gradient modulus will be\nconverted from arcsec to au.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>image:</strong>  input image.</li>\n<li><strong>distance:</strong>  optional; distance to the source.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The modulus and direction arrays of the emission gradient.</p>\n</blockquote>\n", "signature": "(\n    image: astropy.io.fits.hdu.image.PrimaryHDU,\n    distance: Union[astropy.units.quantity.Quantity, NoneType] = None\n) -> Tuple[astropy.io.fits.hdu.image.PrimaryHDU]", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.images.minimal_radius", "modulename": "toolkit.astro_tools.images", "qualname": "minimal_radius", "type": "function", "doc": "<p>The radius where a circle centered at <code>position</code> contains valid data.</p>\n", "signature": "(\n    image: astropy.io.fits.hdu.image.PrimaryHDU,\n    position: astropy.coordinates.sky_coordinate.SkyCoord\n)", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.masking", "modulename": "toolkit.astro_tools.masking", "type": "module", "doc": "<p>Tools for generating masks from image data.</p>\n"}, {"fullname": "toolkit.astro_tools.masking.emission_mask", "modulename": "toolkit.astro_tools.masking", "qualname": "emission_mask", "type": "function", "doc": "<p>Generate a mask from images with emission over a threshold.</p>\n\n<p>An inital mask with the same dimessions as the data in args can be given.\nThe logic <code>and</code> operator is used to combine all the masks.</p>\n\n<p>If threshold is not given, an rms value is estimated for each image in\n<code>args</code> and the threshold will be <code>nsigma*rms</code>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>images:</strong>  input images.</li>\n<li><strong>initial_mask:</strong>  optional; initial mask.</li>\n<li><strong>threshold:</strong>  optional; emission threshold per image.</li>\n<li><strong>nsigma:</strong>  optional; number of rms levels for threshold.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A mask array.</p>\n</blockquote>\n", "signature": "(\n    *images: astropy.io.fits.hdu.image.PrimaryHDU,\n    initial_mask: Union[<built-in function array>, NoneType] = None,\n    threshold: Union[Sequence[astropy.units.quantity.Quantity], NoneType] = None,\n    nsigma: float = 5,\n    log: Callable = <built-in function print>\n) -> <built-in function array>", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.masking.mask_structures", "modulename": "toolkit.astro_tools.masking", "qualname": "mask_structures", "type": "function", "doc": "<p>Identify mask structures and index them.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>maks:</strong>  input mask.</li>\n<li><strong>min_area:</strong>  optional; minimum area in pixels of mask structures.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A mask array with small structures filtered out.\n  An array with the labeled structures.\n  The number of structures identified.</p>\n</blockquote>\n", "signature": "(mask: <built-in function array>, min_area: Optional = None) -> Tuple", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.masking.position_in_mask", "modulename": "toolkit.astro_tools.masking", "qualname": "position_in_mask", "type": "function", "doc": "<p>Returns value of position in mask.</p>\n", "signature": "(\n    position: astropy.coordinates.sky_coordinate.SkyCoord,\n    mask: <built-in function array>,\n    wcs: astropy.wcs.wcs.WCS\n) -> bool", "funcdef": "def"}, {"fullname": "toolkit.astro_tools.masking.plot_mask", "modulename": "toolkit.astro_tools.masking", "qualname": "plot_mask", "type": "function", "doc": "<p>Create a plot of <code>mask</code>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>mask:</strong>  mask array.</li>\n<li><strong>scatter:</strong>  optional; sky coordinates of scatter points.</li>\n<li><strong>wcs:</strong>  optional; coordiante system to interpret the scatter points.</li>\n<li><strong>scatter_kwds:</strong>  optional; keywords for <code>plt.scatter</code>.</li>\n<li><strong>kwargs:</strong>  keywords for <code>plt.subplots</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A tuple with the figure and axis.</p>\n</blockquote>\n", "signature": "(\n    mask: <built-in function array>,\n    scatter: Union[collections.abc.Sequence[astropy.coordinates.sky_coordinate.SkyCoord], NoneType] = None,\n    wcs: Union[astropy.wcs.wcs.WCS, NoneType] = None,\n    scatter_kwds: Union[Dict, NoneType] = None,\n    **kwargs\n) -> tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]", "funcdef": "def"}, {"fullname": "toolkit.converters", "modulename": "toolkit.converters", "type": "module", "doc": "<p>Convert between data types.</p>\n"}, {"fullname": "toolkit.converters.argparser_to_configparser", "modulename": "toolkit.converters", "qualname": "argparser_to_configparser", "type": "function", "doc": "<p>Update a <code>configparser</code> object from the values in <code>args</code>.</p>\n\n<p>If option is in <code>args</code> but not in <code>config</code>, then it is skipped.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>args:</strong>  argument parser object.</li>\n<li><strong>config:</strong>  configuration parser.</li>\n<li><strong>section:</strong>  section of <code>config</code> to update</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>An updated configuration parser.</p>\n</blockquote>\n", "signature": "(\n    args: argparse.Namespace,\n    config: configparser.ConfigParser,\n    section: str\n) -> configparser.ConfigParser", "funcdef": "def"}, {"fullname": "toolkit.converters.array_to_hdu", "modulename": "toolkit.converters", "qualname": "array_to_hdu", "type": "function", "doc": "<p>Convert a <code>np.array</code> to a <code>PrimaryHDU</code>.</p>\n\n<p>If <code>array</code> is a <code>Quantity</code> array and <code>unit</code> is given, then <code>array</code> is\nconverted to unit. Otherwise, if <code>unit</code> is given then it assumed to be the\nunit of <code>array</code>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>array:</strong>  data to convert.</li>\n<li><strong>reference:</strong>  reference image to obtain WCS information.</li>\n<li><strong>unit:</strong>  optional; unit or output unit of the data.</li>\n</ul>\n", "signature": "(\n    array: Union[<built-in function array>, astropy.units.quantity.Quantity],\n    reference: Union[astropy.io.fits.hdu.image.PrimaryHDU, Dict],\n    unit: Union[astropy.units.core.Unit, NoneType] = None\n) -> astropy.io.fits.hdu.image.PrimaryHDU", "funcdef": "def"}, {"fullname": "toolkit.converters.quantity_from_hdu", "modulename": "toolkit.converters", "qualname": "quantity_from_hdu", "type": "function", "doc": "<p>Convert a <code>PrimaryHDU</code> to a <code>Quantity</code>.</p>\n", "signature": "(\n    hdu: astropy.io.fits.hdu.image.PrimaryHDU,\n    unit: Union[astropy.units.core.Unit, NoneType] = None\n) -> astropy.units.quantity.Quantity", "funcdef": "def"}, {"fullname": "toolkit.logger", "modulename": "toolkit.logger", "type": "module", "doc": "<p>Logging tools and classes.</p>\n\n<p>This is a compilation of functions for loading and configuring the logging\nsystem. It also implements a <code>LoggedObject</code> class that can be inherited in\norder to implement logging for the class.</p>\n"}, {"fullname": "toolkit.logger.get_level", "modulename": "toolkit.logger", "qualname": "get_level", "type": "function", "doc": "<p>Convert to numeric logging level.</p>\n", "signature": "(loglevel)", "funcdef": "def"}, {"fullname": "toolkit.logger.get_stdout_format", "modulename": "toolkit.logger", "qualname": "get_stdout_format", "type": "function", "doc": "<p>Determines the stdout format.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>level:</strong>  optional; logging level.</li>\n<li><strong>timestamp:</strong>  optional; include timestamp?</li>\n</ul>\n", "signature": "(level: int = 20, timestamp: bool = False) -> str", "funcdef": "def"}, {"fullname": "toolkit.logger.get_stdout_handler", "modulename": "toolkit.logger", "qualname": "get_stdout_handler", "type": "function", "doc": "<p>Create an standard output handler with the given log level.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>level:</strong>  logging level.</li>\n<li><strong>timestamp:</strong>  optional; add time stamp to default format.</li>\n<li><strong>fmt:</strong>  optional; text format.</li>\n</ul>\n", "signature": "(\n    level: int,\n    timestamp: bool = False,\n    fmt: Union[str, NoneType] = None\n) -> logging.StreamHandler", "funcdef": "def"}, {"fullname": "toolkit.logger.get_file_handler", "modulename": "toolkit.logger", "qualname": "get_file_handler", "type": "function", "doc": "<p>Create a file logging handler.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>level:</strong>  logging level.</li>\n<li><strong>filename:</strong>  logging file name</li>\n</ul>\n", "signature": "(\n    level: int,\n    filename: Union[str, pathlib.Path],\n    timestamp: bool = False,\n    max_bytes: int = 5242880,\n    backup_count: int = 5,\n    fmt: Optional = None\n) -> logging.handlers.RotatingFileHandler", "funcdef": "def"}, {"fullname": "toolkit.logger.get_logger", "modulename": "toolkit.logger", "qualname": "get_logger", "type": "function", "doc": "<p>Creates a new logger.</p>\n\n<p>Verbose levels overwrite the other parameter values. Accepted <code>verbose</code>\nvalues are:</p>\n\n<ul>\n<li><code>None</code>: use the other keyword arguments.</li>\n<li><code>v</code>: basic logging with <code>INFO</code> level for stdout and <code>DEBUG</code> level for\nfile logging.</li>\n<li><code>vv</code>: looging with <code>DEBUG</code> level for stdout and file logging.</li>\n<li><code>vvv</code>: same as verbose <code>vv</code> but add a timestamp to the file name and add\ntime to the stdout log.</li>\n</ul>\n\n<p>Additional appereances of the character <code>v</code> will be ignored.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>name:</strong>  name of the logger.</li>\n<li><strong>filename:</strong>  optional; file name of the log.</li>\n<li><strong>verbose:</strong>  optional; verbose level.</li>\n<li><strong>timestamp:</strong>  optional; add timestamp to log file name.</li>\n<li><strong>stdoutlevel:</strong>  optional; logging level fot std output logging.</li>\n<li><strong>filelevel:</strong>  optional; logging level for file logging.</li>\n<li><strong>max_bytes:</strong>  optional; maximum size of logging file in bytes.</li>\n<li><strong>backup_count:</strong>  optional; maximum number of log files to rotate.</li>\n</ul>\n", "signature": "(\n    name: str,\n    filename: Union[NoneType, str, pathlib.Path] = None,\n    verbose: Union[str, NoneType] = None,\n    timestamp: bool = False,\n    stdoutlevel: int = 20,\n    filelevel: int = 10,\n    max_bytes: int = 5242880,\n    backup_count: int = 5\n) -> logging.Logger", "funcdef": "def"}, {"fullname": "toolkit.logger.get_stdout_logger", "modulename": "toolkit.logger", "qualname": "get_stdout_logger", "type": "function", "doc": "<p>Creates a new standard output logger.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>name:</strong>  name of the logger.</li>\n<li><strong>verbose:</strong>  optional; verbose level.</li>\n<li><strong>timestamp:</strong>  optional; add timestamp to log file name.</li>\n<li><strong>level:</strong>  optional; logging level fot std output logging.</li>\n</ul>\n", "signature": "(\n    name: str,\n    verbose: Union[str, NoneType] = None,\n    timestamp: bool = False,\n    level: int = 20\n) -> logging.Logger", "funcdef": "def"}, {"fullname": "toolkit.logger.update_logger", "modulename": "toolkit.logger", "qualname": "update_logger", "type": "function", "doc": "<p>Update logger handlers.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>logger:</strong>  logger instance.</li>\n<li><strong>filename:</strong>  optional; file name for new file handler.</li>\n<li><strong>verbose:</strong>  optional; update logging levels.</li>\n<li><strong>timestamp:</strong>  optional; default timestamp values for new/updated handlers.</li>\n<li><strong>stdoutlevel:</strong>  optional; change standard output level.</li>\n<li><strong>filelevel:</strong>  optional; change file level.</li>\n<li><strong>max_bytes:</strong>  optional; maximum size of logging file in bytes.</li>\n<li><strong>backup_count:</strong>  optional; maximum number of log files to rotate.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>An updated logger instance.</p>\n</blockquote>\n", "signature": "(\n    logger: logging.Logger,\n    filename: Union[NoneType, str, pathlib.Path] = None,\n    verbose: Union[str, NoneType] = None,\n    timestamp: bool = False,\n    stdoutlevel: int = 20,\n    filelevel: int = 10,\n    max_bytes: int = 5242880,\n    backup_count: int = 5\n) -> logging.Logger", "funcdef": "def"}, {"fullname": "toolkit.logger.LoggedObject", "modulename": "toolkit.logger", "qualname": "LoggedObject", "type": "class", "doc": "<p>Object for logging information to stdout.</p>\n\n<p>The attribute <code>log</code> can be updated and change the verbose level and other\noptions by initializing the object. Else the <code>log</code> will print to the\nstandard output. The logging can be disable if the <code>enabled</code> attribute is\nset to <code>False</code>.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>log:</strong>  logger object.</li>\n<li><strong>enabled:</strong>  enable or disable logging.</li>\n</ul>\n"}, {"fullname": "toolkit.logger.LoggedObject.__init__", "modulename": "toolkit.logger", "qualname": "LoggedObject.__init__", "type": "function", "doc": "<p>Initialize the object and apply options.</p>\n", "signature": "(self, name, **kwargs)", "funcdef": "def"}, {"fullname": "toolkit.logger.LoggedObject.enabled", "modulename": "toolkit.logger", "qualname": "LoggedObject.enabled", "type": "variable", "doc": "<p></p>\n", "default_value": " = True"}, {"fullname": "toolkit.logger.LoggedObject.log", "modulename": "toolkit.logger", "qualname": "LoggedObject.log", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Logger LoggedObject (DEBUG)>"}, {"fullname": "toolkit.logger.LoggedObject.info", "modulename": "toolkit.logger", "qualname": "LoggedObject.info", "type": "function", "doc": "<p>Log an <code>INFO</code> message.</p>\n", "signature": "(self, message: str) -> None", "funcdef": "def"}, {"fullname": "toolkit.logger.LoggedObject.debug", "modulename": "toolkit.logger", "qualname": "LoggedObject.debug", "type": "function", "doc": "<p>Log a <code>DEBUG</code> message.</p>\n", "signature": "(self, message: str) -> None", "funcdef": "def"}, {"fullname": "toolkit.logger.LoggedObject.warn", "modulename": "toolkit.logger", "qualname": "LoggedObject.warn", "type": "function", "doc": "<p>Log a <code>DEBUG</code> message.</p>\n", "signature": "(self, message: str) -> None", "funcdef": "def"}, {"fullname": "toolkit.logger.LoggedObject.error", "modulename": "toolkit.logger", "qualname": "LoggedObject.error", "type": "function", "doc": "<p>Log a <code>DEBUG</code> message.</p>\n", "signature": "(self, message: str) -> None", "funcdef": "def"}, {"fullname": "toolkit.maths", "modulename": "toolkit.maths", "type": "module", "doc": "<p>Maths tools.</p>\n"}, {"fullname": "toolkit.maths.rms", "modulename": "toolkit.maths", "qualname": "rms", "type": "function", "doc": "<p>Root mean square (rms).</p>\n\n<p>The rms of <code>x</code> is defined as:</p>\n\n<pre><code>rms = sqrt( sum(x_i**2) / n )\n</code></pre>\n\n<p>where <code>n</code> is the number of points in <code>x</code>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>x:</strong>  data.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The root mean square of <code>x</code>.</p>\n</blockquote>\n", "signature": "(x: <built-in function array>)", "funcdef": "def"}, {"fullname": "toolkit.maths.quick_rms", "modulename": "toolkit.maths", "qualname": "quick_rms", "type": "function", "doc": "<p>A quick estimation of the rms of the data.</p>\n", "signature": "(data: <built-in function array>)", "funcdef": "def"}, {"fullname": "toolkit.maths.distance_array", "modulename": "toolkit.maths", "qualname": "distance_array", "type": "function", "doc": "<p>Returns an array with the distance of each point to the position.</p>\n\n<p>The <code>position</code> corresponds to the <code>(x, y)</code> position, i.e. in Cartesian\ncoordinates.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>shape:</strong>  shape of the distance matrix.</li>\n<li><strong>position:</strong>  central point.</li>\n<li><strong>mask:</strong>  optional; masked distance value (<code>True</code> if masked).</li>\n</ul>\n", "signature": "(\n    shape: Tuple,\n    position: Tuple,\n    mask: Union[<built-in function array>, NoneType] = None\n)", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();